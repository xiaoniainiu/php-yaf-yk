<?php/** *  Copyright (c) 2013-2014  *  This is no free page *  upload.php  2014-7-26 下午2:49:45  UTF-8 *  @author yky@yky.pw */namespace common;class upload{		//从tmp中移动upload	public static function zoom(&$file, &$maxWidth = 0, &$maxHeight = 0){				list($width, $height, $im, $func, $ext) = self::_init($file);				if (!$im){			\yk\log::runlog('file upload error: im not found', 'upload');			return false;		}				if ($maxWidth > 0){			$p = max($width / $maxWidth, $height / $maxHeight);			$dstwidth = intval($width / $p);			$dstheight = intval($height / $p);		}else{			$dstwidth = $width;			$dstheight = $height;		}		$maxWidth = $dstwidth;		$maxHeight = $dstheight;				$dstim = imagecreatetruecolor($dstwidth, $dstheight);		imagealphablending($dstim, false);        //关闭混杂模式,不可缺少,  PHP文档中说明: (在非混色模式下，画笔颜色连同其 alpha 通道信息一起被拷贝，替换掉目标像素。混色模式在画调色板图像时不可用。)  而且是imagesavealpha方法起作用的前置步骤.		imagesavealpha($dstim, true);        //保存 PNG 图像时保存完整的 alpha 通道信息		$transparent = imagecolorallocatealpha($dstim, 255, 255, 255, 127);        //取得一个透明的颜色,  透明度在 0-127 间		imagefill($dstim, 0, 0, $transparent);		imagecopyresampled($dstim, $im, 0, 0, 0, 0, $dstwidth, $dstheight, $width, $height);				$file = uniqid().$ext;		$ret = $func($dstim, MAIN_PATH.'/data/tmp/'.$file);		imagedestroy($dstim);		imagedestroy($im);		return $ret;	}		public static function movetmp2upload(&$file){		$tmp = MAIN_PATH.'/data/tmp/'.$file;		if (file_exists($tmp)){			$path = self::_create();			$file = $path.$file;			if (rename($tmp, MAIN_PATH.'/public/'.$file)){				return true;			}else{				\yk\log::runlog('file upload error: move failure src:'.$file.', dst: '.$file, 'upload');				return false;				}		}else{			\yk\log::runlog('file upload error: tmp file '.$file.' not found', 'upload');			return false;		}	}		private static function _create(){		$dirs = explode('/', date('Y/m/d'));		$dir = MAIN_PATH.'/public/';		$p = 'upload/';		foreach ($dirs as $path){			$p .= $path.'/';			if (!is_dir($dir.$p)){				mkdir($dir.$p, 0755);			}		}		return $p;	}		private static function _init($file){				$info = getimagesize($file);		$method = $im = $ext = null;		switch ($info['mime']){			case 'image/jpeg':			case 'image/jpg':				$ext = '.jpg';				$im = imagecreatefromjpeg($file);				$method = 'imagejpeg';				break;			case 'image/gif':				$ext = '.gif';				$im = imagecreatefromgif($file);				$method = 'imagegif';				break;			case 'image/png':				$ext = '.png';				$im = imagecreatefrompng($file);				$method = 'imagepng';				break;			case 'image/bmp':				$ext = '.bmp';				$im = imagecreatefrombmp($file);				$method = 'imagepng';				break;			default:				break;		}		return [$info[0], $info[1], $im, $method, $ext];	}	}function imagecreatefrombmp($filename) {	// Ouverture du fichier en mode binaire	if (!$f1 = fopen($filename, "rb")) return false;	// 1 : Chargement des ent?tes FICHIER	$file = unpack("vfile_type/Vfile_size/Vreserved/Vbitmap_offset", fread($f1 ,14));	if ($file['file_type'] != 19778) return false;	// 2 : Chargement des ent?tes BMP	$bmp = unpack('Vheader_size/Vwidth/Vheight/vplanes/vbits_per_pixel' .			'/Vcompression/Vsize_bitmap/Vhoriz_resolution' .			'/Vvert_resolution/Vcolors_used/Vcolors_important', fread($f1, 40));	$bmp['colors'] = pow(2, $bmp['bits_per_pixel']);	if ($bmp['size_bitmap'] == 0 ) $bmp['size_bitmap']= $file['file_size']-$file['bitmap_offset'];	$bmp['bytes_per_pixel'] = $bmp['bits_per_pixel'] / 8 ;	$bmp['bytes_per_pixel2'] = ceil($bmp['bytes_per_pixel']);	$bmp['decal'] = ($bmp['width']*$bmp['bytes_per_pixel'] / 4 );	$bmp['decal'] -= floor ($bmp['width'] * $bmp['bytes_per_pixel'] / 4 );	$bmp['decal'] = 4 - (4 * $bmp['decal']);	if ($bmp['decal'] == 4) $bmp['decal'] = 0 ;	// 3 : Chargement des couleurs de la palette	$PALETTE = array();	if ($bmp['colors'] < 16777216 ){		$PALETTE = unpack('V'.$bmp['colors'], fread($f1, $bmp['colors'] * 4 ));	}	// 4 : Cr?ation de l'image	$IMG = fread($f1, $bmp['size_bitmap']);	$VIDE = chr(0);	$res = imagecreatetruecolor($bmp['width'], $bmp['height']);	$P = 0 ;	$Y = $bmp['height'] - 1 ;	while($Y >= 0){		$X = 0 ;		while ($X < $bmp['width']){			if ($bmp['bits_per_pixel'] == 24 )				$color = unpack("V", substr($IMG, $P, 3).$VIDE);			elseif ($bmp['bits_per_pixel']== 16 ){				$color = unpack("n", substr($IMG, $P, 2));				$color[1] = $PALETTE[$color[1] + 1];			}elseif ($bmp['bits_per_pixel']== 8 ){				$color = unpack("n", $VIDE.substr($IMG, $P, 1));				$color[1] = $PALETTE[$color[ 1 ] + 1];			}elseif ($bmp['bits_per_pixel']== 4 ){				$color = unpack("n", $VIDE.substr($IMG, floor($P), 1));				if (($P * 2) % 2 == 0){					$color[1] = $color[1] >> 4;				}else{					$color[1] = $color[1] & 0x0F;				}				$color[1] = $PALETTE[$color[1] + 1];			}elseif ($bmp['bits_per_pixel'] == 1){				$color = unpack("n", $VIDE.substr($IMG, floor($P), 1));				if(($P * 8) % 8 == 0) $color[1] = $color[1] >> 7 ;				elseif(($P * 8) % 8 == 1) $color[1] = ($color[1] & 0x40) >> 6 ;				elseif(($P * 8) % 8 == 2) $color[1] = ($color[1] & 0x20) >> 5 ;				elseif(($P * 8) % 8 == 3) $color[1] = ($color[1] & 0x10) >> 4 ;				elseif(($P * 8) % 8 == 4) $color[1] = ($color[1] & 0x8) >> 3 ;				elseif(($P * 8) % 8 == 5) $color[1] = ($color[1] & 0x4) >> 2 ;				elseif(($P * 8) % 8 == 6) $color[1] = ($color[1] & 0x2) >> 1 ;				elseif(($P * 8) % 8 == 7) $color[1] = ($color[1] & 0x1);				$color[1] = $PALETTE[$color[1] + 1];			}else return FALSE ;			imagesetpixel($res, $X, $Y, $color[1]);			$X ++ ;			$P += $bmp['bytes_per_pixel'];		}		$Y -- ;		$P += $bmp['decal'];	}	// Fermeture du fichier	fclose($f1);	return $res ;}